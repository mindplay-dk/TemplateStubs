<?php

/**
 * ProcessWire 'TemplateStubs' module
 *
 * @author Rasmus Schultz <http://mindplay.dk/>
 */

/**
 * This module generates 
 */
class TemplateStubs extends WireData implements Module, ConfigurableModule
{
    /**
     * @return array module meta-data
     */
    public static function getModuleInfo()
    {
        return array(
            'title' => 'Template Stubs', 
            'version' => 100, 
            'summary' => 'Generates API stubs for Templates - useful when working with an IDE.',
            'singular' => true, 
            'autoload' => true, 
        );
    }
    
    /**
     * @var string namespace for template-types
     */
    public $namespace = 'tpl';
    
    /**
     * @var (string|Closure)[] hash where field-type class-name => property-type (or function(Field $field) : string)
     */
    public static $return_types;
    
    /**
     * @var bool true, if changes were detected that require template stubs to be rebuilt
     */
    protected $must_rebuild = false;
    
    /**
     * Initialize the module
     */
    public function init()
    {
        self::$return_types = array(
            'FieldtypeComments' => 'CommentArray|Comment[]',
            'FieldtypeRepeater' => 'RepeaterPageArray|Page[]',
            'FieldtypeCheckbox' => 'int',
            'FieldtypeDatetime' => 'int|string',
            'FieldtypeImage' => function (Field $field) {
                return $field->maxFiles == 1
                    ? 'Pageimage'
                    : 'Pageimages|Pageimage[]';
            },
            'FieldtypeFile' => function (Field $field) {
                return $field->maxFiles == 1
                    ? 'Pagefile'
                    : 'Pagefiles|Pagefile[]';
            },
            'FieldtypeFloat' => 'float',
            'FieldtypeInteger' => 'int',
            'FieldtypeModule' => 'string',
            'FieldtypePage' => function (Field $field) {
                $pageType = 'Page';
                
                if ($field->template_id) {
                    $template = wire('templates')->get($field->template_id);
                    
                }
                
                switch ($field->derefAsPage) {
                    case FieldtypePage::derefAsPageArray:
                        return "PageArray|{$pageType}[]";
                    case FieldtypePage::derefAsPageOrFalse:
                        return '{$pageType}|false';
                    case FieldtypePage::derefAsPageOrNullPage:
                        return '{$pageType}|NullPage';
                    default:
                        return 'mixed';
                }
            },
            'FieldtypePassword' => 'Password',
            // final fall-back types:
            'FieldtypeText' => 'string',
            'FieldtypeMulti' => 'array',
        );
    }
    
    /**
     * Install hooks (only if the rendered Page is an admin-page)
     */
    public function ready()
    {
        if ($this->page->template == 'admin') {
            // Hooks that raise the $must_rebuild flag:
            $this->addHookAfter('Templates::save', $this, 'mustRebuild');
            $this->addHookAfter('Fields::save', $this, 'mustRebuild');
            
            // Hooks for rebuild() after page-view and/or before redirect:
            $this->addHookBefore('Session::redirect', $this, 'rebuild');
            $this->addHookAfter('ProcessPageView::finished', $this, 'rebuild');
        }
    }

    /**
     * Install the setup menu shortcut
     */
    public function ___install()
    {
        $this->must_rebuild = true;
        
        $this->rebuild();
    }
    
    /**
     * @param Template $template the Template for which to generate a class-name
     * @return string documentation stub class-name (without namespace)
     */
    protected function getClassName(Template $template)
    {
        return str_replace(' ', '', strtr($template->name, '-', ' '));
    }
    
    /**
     * @return string Page property-type for the given Field
     */
    protected function getPropertyType(Field $field)
    {
        $type = $field->type;
        
        foreach (self::$return_types as $field_type => $property_type) {
            if ($type instanceof $field_type) {
                return is_callable($property_type)
                    ? $property_type($field)
                    : $property_type;
            }
        }
        
        return 'mixed';
    }
    
    /**
     * @param Template $template the template for which to generate an API documentation stub
     * @return string PHP stub code (documentation only)
     */
    protected function createStub(Template $template)
    {
        /**
         * @var InputField $field
         */

        $stub = "/**\n * \"{$template->name}\" template\n *\n";

        foreach ($template->fields as $field) {
            $name = $field->name;
            $field_type = get_class($field->type);
            $description = $field->get('description|label|name');
            $type = $this->getPropertyType($field);
            
            $stub .= " * @property {$type} \${$name} {$description}\n";
        }
        
        $class = $this->getClassName($template);

        $stub .= " */\nclass ".$class." extends Page\n{}\n";
        
        return $stub;
    }
    
    /**
     * @return string documentation file output path
     */
    public function getOutputPath()
    {
        return dirname(__FILE__) . DIRECTORY_SEPARATOR . 'stubs.php';
    }
    
    /**
     * Raise a flag that triggers documentation rebuild at the end of the request
     */
    public function mustRebuild(HookEvent $event)
    {
        $this->must_rebuild = true;
    }
    
    /**
     * Rebuild the template stubs
     *
     * @param HookEvent|null $event Event object (unused)
     */
    public function rebuild(HookEvent $event = null)
    {
        /**
         * @var Template $template
         */
        
        if (false === $this->must_rebuild) {
            return; // no changes were made, no rebuild necessary
        }
        
        $time = date('Y-m-d H:i:s');
        
        $stubs = "<?php\n\n"
            . "/**\n * Generated by TemplateStubs module $time"
            . "\n * This file may be overwritten at any time."
            . "\n */\n\nnamespace {$this->namespace};\n\nuse Page;\n\n";
        
        foreach (wire('templates') as $template) {
            $stubs .= $this->createStub($template) . "\n";
        }
        
        file_put_contents($this->getOutputPath(), $stubs);
        
        $this->must_rebuild = false;
    }
    
    /**
     * Builds the Module configuration form.
     *
     * @param array $data module configuration values
     *
     * @return InputfieldsWrapper|InputfieldWrapper
     */
    static public function getModuleConfigInputfields(array $data)
    {
        $modules = Wire::getFuel('modules');
        
        $fields = new InputfieldWrapper();
        
        $markup = wire('modules')->get('InputfieldMarkup');
        
        $markup->markupText = '<h2>TemplateStubs</h2>'
            . '<p>Documentation stubs for Templates will be written to:</p>'
            . '<pre>' . htmlspecialchars(wire('modules')->TemplateStubs->getOutputPath()) . '</pre>';
        
        $fields->append($markup);

        return $fields;
    }
}
